"use strict";(self["webpackChunkramp_website"]=self["webpackChunkramp_website"]||[]).push([[5599],{95599:function(e,t,i){i.d(t,{V:function(){return j}});var s=i(44444),n=i(10413),a=i(32707),r=i(94706),l=i(47426),o=i(59064);let u=class{constructor(e,t){this._cache=new s.d_(e),this._invalidCache=new s.d_(t)}get(e,t){const i=`${t.uid}:${e}`,s=this._cache.get(i);if(s)return s;if(null!=this._invalidCache.get(i))return null;try{const s=n.Z.create(e,{fieldsIndex:t});return this._cache.put(i,s),s}catch(a){return this._invalidCache.put(i,a),null}}getError(e,t){const i=`${t.uid}:${e}`;return this._invalidCache.get(i)??null}};const c=new u(50,500),d="unsupported-query",h=" as ",m=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),f=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),p=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...m,...f]);function y(e,t,i={}){const n=F(t,e);if(!n){const i=c.getError(t,e);throw new s.s(d,"invalid SQL expression",{expression:t,error:i})}const a=i.expressionName||"expression";if(i.validateStandardized&&!n.isStandardized)throw new s.s(d,`${a} is not standard`,{expression:t});if(i.validateAggregate&&!n.isAggregate)throw new s.s(d,`${a} does not contain a valid aggregate function`,{expression:t});return n.fieldNames}function g(e,t,i,s){if(!i)return!0;const n="where clause";return b(e,t,y(e,i,{validateStandardized:!0,expressionName:n}),{expressionName:n,query:s}),!0}function x(e,t,i,n,a){if(!i)return!0;const r="having clause",l=y(e,i,{validateAggregate:!0,expressionName:r});if(b(e,t,l,{expressionName:r,query:a}),!F(i,e)?.getExpressions().every((t=>{const{aggregateType:i,field:s}=t,a=e.get(s)?.name;return n.some((t=>{const{onStatisticField:s,statisticType:n}=t;return e.get(s)?.name===a&&n.toLowerCase().trim()===i}))})))throw new s.s(d,"expressions in having clause should also exist in outStatistics",{having:i});return!0}function F(e,t){return e?c.get(e,t):null}function _(e){return/\((.*?)\)/.test(e)?e:e.split(h)[0]}function w(e){return e.split(h)[1]}function b(e,t,i,n={}){const a=new Map;if(v(a,e,t,n.allowedFieldTypes??p,i),a.size){const e=n.expressionName??"expression";throw new s.s(d,`${e} contains invalid or missing fields`,{errors:Array.from(a.values()),query:n.query})}}function v(e,t,i,s,n){const a=n.includes("*")?[...i,...n.filter((e=>"*"!==e))]:n;for(const l of a)if(t.get(l))I(e,t,i,s,l);else try{const n=y(t,_(l),{validateStandardized:!0});for(const a of n)I(e,t,i,s,a)}catch(r){e.set(l,{type:"expression-error",expression:l,error:r})}}function I(e,t,i,n,a){const r=t.get(a);r?i.has(r.name)?"all"!==n&&!1===n?.has(r.type)&&e.set(a,{type:"invalid-type",fieldName:r.name,fieldType:s.dc.fromJSON(r.type),allowedFieldTypes:Array.from(n,(e=>s.dc.fromJSON(e)))}):e.set(a,{type:"missing-field",fieldName:r.name}):e.set(a,{type:"invalid-field",fieldName:a})}const S=5;let T=class{constructor(){this._storage=new Map,this._purgeInterval=S,this._sweep=()=>{if(this._timer=void 0,!this._storage)return;const e=1e3*this._purgeInterval,t=performance.now()-e;for(const[i,s]of this._storage){if(!(s.time<t))return void(this._storage.size>0&&(this._timer=setTimeout(this._sweep,e)));this._storage.delete(i)}}}destroy(){this._storage?.clear(),this._storage=null,clearTimeout(this._timer)}get size(){return this._storage?.size??0}put(e,t){this._storage?.set(e,new R(t)),this._scheduleSweep()}get(e){if(!this._storage)return;const t=this._storage?.get(e);return t?(this._storage?.delete(e),t.time=performance.now(),this._storage?.set(e,t),t.items):void 0}clear(){this._storage?.clear()}_scheduleSweep(){this._storage&&(this._timer??=setTimeout(this._sweep,1e3*this._purgeInterval))}},V=0;class R{constructor(e){this.items=e,this.time=performance.now(),this.id=V++}}let z=class{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&!s.includes("*")){this.outFields=s;let e=0;for(const t of s){const s=_(t),n=this.fieldsIndex.get(s),a=n?null:F(s,i),r=n?n.name:w(t)||"FIELD_EXP_"+e++;this._fieldDataCache.set(t,{alias:r,clause:a})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach((e=>this.getAttributes(e))),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let n=null;return this._fieldDataCache.has(s)?n=this._fieldDataCache.get(s)?.clause:i||(n=F(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:n})),i?this.featureAdapter.getAttribute(e,s):n?.calculateValue(e,this.featureAdapter)}getDataValues(e,t,i=!0){const n=t.normalizationType,a=t.normalizationTotal,r=this.fieldsIndex.get(t.field),u=(0,s.bW)(r)||(0,s.bX)(r),c=(0,s.d0)(r);return e.map((e=>{let s=t.field&&this.getFieldValue(e,t.field,this.fieldsIndex.get(t.field));if(t.field2?(s=`${(0,o.m)(s)}${t.fieldDelimiter}${(0,o.m)(this.getFieldValue(e,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(s=`${s}${t.fieldDelimiter}${(0,o.m)(this.getFieldValue(e,t.field3,this.fieldsIndex.get(t.field3)))}`)):"string"==typeof s&&i&&(u?s=s?new Date(s).getTime():null:c&&(s=s?(0,l.I)(s):null)),n&&Number.isFinite(s)){const i="field"===n&&t.normalizationField?this.getFieldValue(e,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;s=(0,o.B)(s,n,i,a)}return s}))}async getExpressionValues(e,t,i,n,r){const{arcadeUtils:l}=await(0,s.d1)(),o=l.hasGeometryOperations(t);o&&await l.enableGeometryOperations();const u=l.createFunction(t),c=l.getViewInfo(i),d={fields:this.fieldsIndex.fields};return e.map((e=>{const t={attributes:this.featureAdapter.getAttributes(e),layer:d,geometry:o?{...(0,a.a)(n.geometryType,n.hasZ,n.hasM,this.featureAdapter.getGeometry(e)),spatialReference:i?.spatialReference}:null},s=l.createExecContext(t,c,r);return l.executeFunction(u,s)}))}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:F(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testFeature(e,this.featureAdapter)??!1}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:F(t,this.fieldsIndex)}),this._fieldDataCache.get(t)?.clause?.testSet(e,this.featureAdapter)??!1}_processAttributesForOutFields(e){const t=this.outFields;if(!t?.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:t,clause:n}=this._fieldDataCache.get(s);i[t]=n?n.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,t)}return i}_processAttributesForDistinctValues(e){if(null==e||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const a of t){const{alias:t}=this._fieldDataCache.get(a);i.push(e[t])}else for(const a in e)i.push(e[a]);const s=`${(t||["*"]).join(",")}=${i.join(",")}`;let n=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++n),n>1?null:e}};function A(e,t,i){return{objectId:e,target:t,distance:i,type:"vertex"}}function M(e,t,i,s,n,a=!1){return{objectId:e,target:t,distance:i,type:"edge",start:s,end:n,draped:a}}class D{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new z(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query;if(!t?.length)return 1;const n=new Map,a=new Map,r=new Set;for(const l of s){const{statisticType:s}=l,o="exceedslimit"!==s?l.onStatisticField:void 0;if(!a.has(o)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,n);i.push(t)}a.set(o,this._calculateUniqueValues(i,e.returnDistinctValues))}const u=a.get(o);for(const t in u){const{data:s,items:n}=u[t],a=s.join(",");i&&!e.validateItems(n,i)||r.add(a)}}return r.size}async createQueryResponse(){let e;if(e=this.query.outStatistics?this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;(0,s.du)(this.query.outSR)&&!(0,s.a5)(t.spatialReference,this.query.outSR)?e.queryGeometry=(0,a.h)({spatialReference:this.query.outSR,...(0,s.di)(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=(0,a.h)({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t){const i=this.featureAdapter,s=C(this.hasZ,this.hasM),{point:n,mode:a}=e,r="number"==typeof e.distance?e.distance:e.distance.x,l="number"==typeof e.distance?e.distance:e.distance.y,o={candidates:[]},u="esriGeometryPolygon"===this.geometryType,c=this._getPointCreator(a,this.spatialReference,t),d=new N(null,0),h=new N(null,0),m={x:0,y:0,z:0};for(const f of this.items){const t=i.getGeometry(f);if(null==t)continue;const{coords:a,lengths:p}=t;if(d.coords=a,h.coords=a,e.returnEdge){let e=0;for(let t=0;t<p.length;t++){const a=p[t];for(let t=0;t<a;t++,e+=s){const u=d;if(u.coordsIndex=e,t!==a-1){const t=h;t.coordsIndex=e+s;const a=m;E(m,n,u,t);const d=(n.x-a.x)/r,p=(n.y-a.y)/l,y=d*d+p*p;y<=1&&o.candidates.push(M(i.getObjectId(f),c(a),Math.sqrt(y),c(u),c(t)))}}}}if("none"!==e.vertexMode){const t=u?a.length-s:a.length;if("all"===e.vertexMode)for(let e=0;e<t;e+=s){const t=d;t.coordsIndex=e;const s=(n.x-t.x)/r,a=(n.y-t.y)/l,u=s*s+a*a;u<=1&&o.candidates.push(A(i.getObjectId(f),c(t),Math.sqrt(u)))}else if("ends"===e.vertexMode){const e=[0];u||e.push(a.length-s);for(const t of e){const e=d;e.coordsIndex=t;const s=(n.x-e.x)/r,a=(n.y-e.y)/l,u=s*s+a*a;u<=1&&o.candidates.push(A(i.getObjectId(f),c(e),Math.sqrt(u)))}}}}return o.candidates.sort(((e,t)=>e.distance-t.distance)),o}_getPointCreator(e,t,i){const n=null==i||(0,s.a5)(t,i)?e=>e:e=>(0,s.di)(e,t,i),{hasZ:a}=this,r=0;return"3d"===e?a?({x:e,y:t,z:i})=>n({x:e,y:t,z:i}):({x:e,y:t})=>n({x:e,y:t,z:r}):({x:e,y:t})=>n({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:n,normalizationType:a,normalizationTotal:r,minValue:l,maxValue:u,scale:c,timeZone:d,outStatisticTypes:h}=e,m=this.fieldsIndex.get(t),f=(0,s.bV)(m)||(0,s.bW)(m)||(0,s.bX)(m),p=await this._getDataValues({field:t,valueExpression:i,normalizationField:n,normalizationType:a,normalizationTotal:r,scale:c,timeZone:d}),y=(0,o.d)({normalizationType:a,normalizationField:n,minValue:l,maxValue:u}),g={value:.5,fieldType:m?.type},x=(0,s.ds)(m)?(0,o.f)({values:p,supportsNullCount:y,percentileParams:g,outStatisticTypes:h}):(0,o.p)({values:p,minValue:l,maxValue:u,useSampleStdDev:!a,supportsNullCount:y,percentileParams:g,outStatisticTypes:h});return(0,o.C)(x,h,f)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:n,scale:a,timeZone:r}=e,l=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:a,timeZone:r},!1),u=(0,o.k)(l);return(0,o.$)(u,s,n,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:d,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:h,timeZone:m}),p=(0,o.E)(f,{field:t,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:d});return(0,o.P)(p,r)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:d,scale:h,timeZone:m}=e,f=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:n,normalizationTotal:a,scale:h,timeZone:m});return(0,o.U)(f,{field:t,normalizationField:s,normalizationType:n,normalizationTotal:a,classificationMethod:r,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:d})}_sortFeatures(e,t,i){if(e.length>1&&t?.length)for(const s of t.reverse()){const t=s.split(" "),n=t[0],a=this.fieldsIndex.get(n),r=!!t[1]&&"desc"===t[1].toLowerCase(),l=(0,o.g)(a?.type,r);e.sort(((e,t)=>{const s=i(e,n,a),r=i(t,n,a);return l(s,r)}))}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:n,hasZ:r,objectIdField:l,spatialReference:o}=this,{outFields:u,outSR:c,quantizationParameters:d,resultRecordCount:h,resultOffset:m,returnZ:f,returnM:p}=e,y=null!=h&&t.length>(m||0)+h,g=u&&(u.includes("*")?[...this.fieldsIndex.fields]:u.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:g,geometryType:i,hasM:n&&p,hasZ:r&&f,objectIdFieldName:l,spatialReference:(0,a.h)(c||o),transform:d&&(0,s.mu)(d)||null}}_createFeatures(e,t){const i=new z(e,this.featureAdapter,this.fieldsIndex),{hasM:n,hasZ:r}=this,{orderByFields:l,quantizationParameters:o,returnGeometry:u,returnCentroid:c,maxAllowableOffset:d,resultOffset:h,resultRecordCount:m,returnZ:f=!1,returnM:p=!1}=e,y=r&&f,g=n&&p;let x=[],F=0;const _=[...t];if(this._sortFeatures(_,l,((e,t,s)=>i.getFieldValue(e,t,s))),this.geometryType&&(u||c)){const e=(0,s.mu)(o)??void 0,t="esriGeometryPolygon"===this.geometryType||"esriGeometryPolyline"===this.geometryType;if(u&&!c)for(const s of _){const n=this.featureAdapter.getGeometry(s),r={attributes:i.getAttributes(s),geometry:(0,a.a)(this.geometryType,this.hasZ,this.hasM,n,d,e,y,g)};t&&n&&!r.geometry&&(r.centroid=(0,a.y)(this,this.featureAdapter.getCentroid(s,this),e)),x[F++]=r}else if(!u&&c)for(const s of _)x[F++]={attributes:i.getAttributes(s),centroid:(0,a.y)(this,this.featureAdapter.getCentroid(s,this),e)};else for(const s of _)x[F++]={attributes:i.getAttributes(s),centroid:(0,a.y)(this,this.featureAdapter.getCentroid(s,this),e),geometry:(0,a.a)(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(s),d,e,y,g)}}else for(const s of _){const e=i.getAttributes(s);e&&(x[F++]={attributes:e})}const w=h||0;if(null!=m){const e=w+m;x=x.slice(w,Math.min(x.length,e))}return x}_createExceedsLimitQueryResponse(e){let t=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY;for(const a of e.outStatistics??[])if("exceedslimit"===a.statisticType){i=null!=a.maxPointCount?a.maxPointCount:Number.POSITIVE_INFINITY,s=null!=a.maxRecordCount?a.maxRecordCount:Number.POSITIVE_INFINITY,n=null!=a.maxVertexCount?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)t=this.items.length>i;else if(this.items.length>s)t=!0;else{const e=C(this.hasZ,this.hasM),i=this.featureAdapter;t=this.items.reduce(((e,t)=>{const s=i.getGeometry(t);return e+(null!=s&&s.coords.length||0)}),0)/e>n}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],n=new Map,a=new Map,r=new Map,l=new Map,o=new z(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:d,orderByFields:h,resultRecordCount:m}=e,f=c?.length,p=!!f,y=p?c[0]:null,g=p&&!this.fieldsIndex.get(y);for(const F of u??[]){const{outStatisticFieldName:e,statisticType:u}=F,h=F,m="exceedslimit"!==u?F.onStatisticField:void 0,x="percentile_disc"===u||"percentile_cont"===u,_="EnvelopeAggregate"===u||"CentroidAggregate"===u||"ConvexHullAggregate"===u,w=p&&1===f&&(m===y||g)&&"count"===u;if(p){if(!r.has(m)){const e=[];for(const t of c){const i=this._getAttributeValues(o,t,n);e.push(i)}r.set(m,this._calculateUniqueValues(e,!_&&o.returnDistinctValues))}const t=r.get(m);if(!t)continue;const i=Object.keys(t);for(const s of i){const{count:i,data:a,items:r,itemPositions:u}=t[s],f=a.join(",");if(!d||o.validateItems(r,d)){const t=l.get(f)||{attributes:{}};if(_){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(h,r);t.aggregateGeometries[i]=e}else{let s=null;if(w)s=i;else{const e=this._getAttributeValues(o,m,n),t=u.map((t=>e[t]));s=x&&"statisticParameters"in h?this._getPercentileValue(h,t):this._getStatisticValue(h,t,null,o.returnDistinctValues)}t.attributes[e]=s}let s=0;c.forEach(((e,i)=>t.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++s]=a[i])),l.set(f,t)}}}else if(_){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(h,this.items);t.aggregateGeometries[i]=e}else{const i=this._getAttributeValues(o,m,n);t.attributes[e]=x&&"statisticParameters"in h?this._getPercentileValue(h,i):this._getStatisticValue(h,i,a,o.returnDistinctValues)}const b="min"!==u&&"max"!==u||!(0,s.ds)(this.fieldsIndex.get(m))&&!this._isAnyDateField(m)?null:this.fieldsIndex.get(m)?.type;i.push({name:e,alias:e,type:b||"esriFieldTypeDouble"})}const x=p?Array.from(l.values()):[t];return this._sortFeatures(x,h,((e,t)=>e.attributes[t])),m&&(x.length=Math.min(m,x.length)),{fields:i,features:x}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return(0,s.bV)(t)||(0,s.bW)(t)||(0,s.bX)(t)||(0,s.d0)(t)}async _getAggregateGeometry(e,t){const{convexHull:n,union:r}=await Promise.all([i.e(6239),i.e(3270)]).then(i.bind(i,43270)).then((e=>e.g)),{statisticType:l,outStatisticFieldName:o}=e,{featureAdapter:u,spatialReference:c,geometryType:d,hasZ:h,hasM:m}=this,f=t.map((e=>(0,a.a)(d,h,m,u.getGeometry(e)))),p=n(c,f,!0)[0],y={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===l){const e=p?(0,s.mv)(p):(0,s.mw)(r(c,f));y.aggregateGeometries={...e,spatialReference:c},y.outStatisticFieldName=o||"extent"}else if("CentroidAggregate"===l){const e=p?(0,s.lu)(p):(0,s.mx)((0,s.mw)(r(c,f)));y.aggregateGeometries={x:e[0],y:e[1],spatialReference:c},y.outStatisticFieldName=o||"centroid"}else"ConvexHullAggregate"===l&&(y.aggregateGeometries=p,y.outStatisticFieldName=o||"convexHull");return y}_getStatisticValue(e,t,i,n){const{onStatisticField:a,statisticType:r}=e;let l=null;return l=i?.has(a)?i.get(a):(0,s.ds)(this.fieldsIndex.get(a))||this._isAnyDateField(a)?(0,o.f)({values:t,returnDistinct:n}):(0,o.p)({values:n?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,l),l["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:n}=e,{value:a,orderBy:r}=s,l=this.fieldsIndex.get(i);return(0,o.v)(t,{value:a,orderBy:r,fieldType:l?.type,isDiscrete:"percentile_disc"===n})}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),n=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,n),n}_calculateUniqueValues(e,t){const i={},s=this.items,n=s.length;for(let a=0;a<n;a++){const n=s[a],r=[];for(const t of e)r.push(t[a]);const l=r.join(",");null==i[l]?i[l]={count:1,data:r,items:[n],itemPositions:[a]}:(t||i[l].count++,i[l].items.push(n),i[l].itemPositions.push(a))}return i}async _getDataValues(e,t=!0){const i=new z(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:n,scale:a,timeZone:r}=e;return n?i.getExpressionValues(this.items,n,{viewingMode:"map",scale:a,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},r):i.getDataValues(this.items,(0,s.T)(e),t)}}function E(e,t,i,s){const n=s.x-i.x,a=s.y-i.y,r=n*n+a*a,l=(t.x-i.x)*n+(t.y-i.y)*a,o=Math.min(1,Math.max(0,l/r));e.x=i.x+n*o,e.y=i.y+a*o}function C(e,t){return e?t?4:3:t?3:2}class N{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const q="unsupported-query";async function P(e,{fieldsIndex:t,geometryType:i,spatialReference:n,availableFields:r}){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption&&"xyFootprint"!==e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new s.s(q,"Unsupported query options",{query:e});return Q(t,r,e),O(t,r,e),Promise.all([(0,a.v)(e,i,n),(0,s.df)(n,e.outSR)]).then((()=>e))}function Q(e,t,i){const{outFields:n,orderByFields:a,returnDistinctValues:r,outStatistics:l}=i,o=l?l.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(a&&a.length>0){const s=" asc",n=" desc",r=a.map((e=>{const t=e.toLowerCase();return t.includes(s)?t.split(s)[0]:t.includes(n)?t.split(n)[0]:e})).filter((e=>!o.includes(e)));b(e,t,r,{expressionName:"orderByFields",query:i})}if(n&&n.length>0)b(e,t,n,{expressionName:"outFields",query:i,allowedFieldTypes:"all"});else if(r)throw new s.s(q,"outFields should be specified for returnDistinctValues",{query:i});g(e,t,i.where,i)}const G=new Set([...m,...f]);function O(e,t,i){const{outStatistics:n,groupByFieldsForStatistics:a,having:r}=i,l=a?.length,o=n?.length;if(r){if(!l||!o)throw new s.s(q,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:i});x(e,t,r,n,i)}if(o){if(!B(n))return;const r=n.map((e=>e.onStatisticField)).filter(Boolean);b(e,t,r,{expressionName:"onStatisticFields",query:i}),l&&b(e,t,a,{expressionName:"groupByFieldsForStatistics",query:i});for(const a of n){const{onStatisticField:n,statisticType:r}=a;if("percentile_disc"!==r&&"percentile_cont"!==r||!("statisticParameters"in a))e.get(n)&&"count"!==r&&"min"!==r&&"max"!==r&&b(e,t,[n],{expressionName:`outStatistics with '${r}' statistic type`,allowedFieldTypes:G,query:i});else{const{statisticParameters:e}=a;if(!e)throw new s.s(q,"statisticParameters should be set for percentile type",{definition:a,query:i})}}}}async function Z(e,t,{fieldsIndex:i,geometryType:n,spatialReference:r,availableFields:l}){if((e.distance??0)<0||null!=e.geometryPrecision||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new s.s(q,"Unsupported query options",{query:e});return Q(i,l,e),Promise.all([k(i,l,t,e),(0,a.v)(e,n,r),(0,s.df)(r,e.outSR)]).then((()=>e))}async function k(e,t,i,n){let a=[];if(i.valueExpression){const{arcadeUtils:e}=await(0,s.d1)();a=e.extractFieldNames(i.valueExpression)}if(i.field&&a.push(i.field),i.field2&&a.push(i.field2),i.field3&&a.push(i.field3),i.normalizationField&&a.push(i.normalizationField),!a.length&&!i.valueExpression)throw new s.s(q,"field or valueExpression is required",{params:i});b(e,t,a,{expressionName:"statistics",query:n})}function B(e){return null!=e&&e.every((e=>"exceedslimit"!==e.statisticType))}const $="unsupported-query";class j{constructor(e){this._cache=new T,this._changeHandle=null,this.capabilities={query:r.t},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=e.timeInfo,this.fieldsIndex=(0,s.b4)(e.fieldsIndex)?e.fieldsIndex:s.db.fromJSON(e.fieldsIndex),!e.availableFields||1===e.availableFields.length&&"*"===e.availableFields[0]?this.availableFields=new Set(this.fieldsIndex.fields.map((e=>e.name))):this.availableFields=new Set(e.availableFields.map((e=>this.fieldsIndex.get(e)?.name)).filter((e=>null!=e))),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=(0,s.my)(this._frameTask),this.clearCache(),(0,s.ch)(this._cache),this._changeHandle=(0,s.my)(this._changeHandle)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){this._cache.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(e,t){const i=(0,s.mz)(t);try{return await(await this._executeQuery(e,{},i)).createQueryResponse()}catch(n){if(n!==s.mA)throw n;return new D([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){const i=(0,s.mz)(t);try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},i)).createQueryResponseForCount()}catch(n){if(n!==s.mA)throw n;return 0}}async executeQueryForExtent(e,t){const i=(0,s.mz)(t),n=e.outSR;try{const t=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),s=t.size;return s?{count:s,extent:await this._getBounds(t.items,t.spatialReference,n||this.spatialReference)}:{count:0,extent:null}}catch(a){if(a===s.mA)return{count:0,extent:null};throw a}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then((e=>Array.from(e)))}async executeQueryForIdSet(e,t){const i=(0,s.mz)(t);try{const t=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},i),s=t.items,n=new Set;return await this._reschedule((()=>{for(const e of s)n.add(t.featureAdapter.getObjectId(e))}),i),n}catch(n){if(n===s.mA)return new Set;throw n}}async executeQueryForSnapping(e,t){const i=(0,s.mz)(t),{point:n,distance:a,returnEdge:r,vertexMode:l}=e;if(!r&&"none"===l)return{candidates:[]};let o=(0,s.T)(e.query);o=await this._schedule((()=>(0,s.mB)(o,this.definitionExpression,this.spatialReference)),i),o=await this._reschedule((()=>P(o,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const u=!(0,s.a5)(n.spatialReference,this.spatialReference);u&&await(0,s.df)(n.spatialReference,this.spatialReference);const c="number"==typeof a?a:a.x,d="number"==typeof a?a:a.y,h={xmin:n.x-c,xmax:n.x+c,ymin:n.y-d,ymax:n.y+d,spatialReference:n.spatialReference},m=u?(0,s.di)(h,this.spatialReference):h;if(!m)return{candidates:[]};const f=(await(0,s.a0)((0,s.f1)(n),null,{signal:i}))[0],p=(await(0,s.a0)((0,s.f1)(m),null,{signal:i}))[0];if(null==f||null==p)return{candidates:[]};const y=new D(await this._reschedule((()=>this._searchFeatures(U(p.toJSON()))),i),o,this);await this._reschedule((()=>this._executeObjectIdsQuery(y)),i),await this._reschedule((()=>this._executeTimeQuery(y)),i),await this._reschedule((()=>this._executeAttributesQuery(y)),i),await this._reschedule((()=>this._executeGeometryQueryForSnapping(y,i)),i);const g=f.toJSON(),x=u?(0,s.di)(g,this.spatialReference):g,F=u?Math.max(m.xmax-m.xmin,m.ymax-m.ymin)/2:a;return y.createSnappingResponse({...e,point:x,distance:F},n.spatialReference)}async executeQueryForLatestObservations(e,t){const i=(0,s.mz)(t);if(!this.timeInfo?.trackIdField)throw new s.s($,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const t=await this._executeQuery(e,{},i);return await this._reschedule((()=>this._filterLatest(t)),i),await t.createQueryResponse()}catch(n){if(n!==s.mA)throw n;return new D([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,i){const n=(0,s.mz)(i),{field:a,normalizationField:r,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:a,normalizationField:r,valueExpression:l},n)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,i){const n=(0,s.mz)(i),{field:a,field2:r,field3:l,valueExpression:o}=t;return(await this._executeQueryForStatistics(e,{field:a,field2:r,field3:l,valueExpression:o},n)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,i){const n=(0,s.mz)(i),{field:a,normalizationField:r,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:a,normalizationField:r,valueExpression:l},n)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,i){const n=(0,s.mz)(i),{field:a,normalizationField:r,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:a,normalizationField:r,valueExpression:l},n)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const t=(0,s.mz)(e);this._timeExtentPromise||=(0,a.b)(this.timeInfo,this.featureStore);const[i,n]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return(0,s.J)(t),{fullExtent:i,timeExtent:n}}async _getBounds(e,t,i){const n=(0,s.mC)((0,s.cE)(),s.cF);await this.featureStore.forEachBounds(e,(e=>(0,s.cH)(n,e)));const r={xmin:n[0],ymin:n[1],xmax:n[3],ymax:n[4],spatialReference:(0,a.h)(this.spatialReference)};this.hasZ&&isFinite(n[2])&&isFinite(n[5])&&(r.zmin=n[2],r.zmax=n[5],r.hasZ=!0);const l=(0,s.di)(r,t,i);if(l.spatialReference=(0,a.h)(i),l.xmax-l.xmin==0){const e=(0,s.cm)(l.spatialReference);l.xmin-=e,l.xmax+=e}if(l.ymax-l.ymin==0){const e=(0,s.cm)(l.spatialReference);l.ymin-=e,l.ymax+=e}if(this.hasZ&&null!=l.zmin&&null!=l.zmax&&l.zmax-l.zmin==0){const e=(0,s.cm)(l.spatialReference);l.zmin-=e,l.zmax+=e}return l}_getFullExtent(){return this._fullExtentPromise||="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then((e=>this._getBounds(e,this.spatialReference,this.spatialReference))),this._fullExtentPromise}async _schedule(e,t){return null!=this._frameTask?this._frameTask.schedule(e,t):e(s.mD)}async _reschedule(e,t){return null!=this._frameTask?this._frameTask.reschedule(e,t):e(s.mD)}async _getAllFeaturesQueryEngineResult(e){return new D(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(null==this._allFeaturesPromise){const e=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach((t=>e.push(t)))})().then((()=>e))}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,i){e=(0,s.T)(e),e=await this._schedule((()=>(0,s.mE)(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>P(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i),e={...e,...t};const n=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),a=await this._reschedule((()=>this._executeGeometryQuery(e,n,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(a)),i),await this._reschedule((()=>this._executeObjectIdsQuery(a)),i),await this._reschedule((()=>this._executeTimeQuery(a)),i),await this._reschedule((()=>this._executeAttributesQuery(a)),i),a}async _executeSceneFilterQuery(e,t){if(null==e.sceneFilter)return null;const{outSR:i,returnGeometry:n,returnCentroid:r}=e,l=this.featureStore.featureSpatialReference,o=e.sceneFilter.geometry,u=null==l||(0,s.a5)(l,o.spatialReference)?o:(0,s.di)(o,l);if(!u)return null;const c=n||r,d=(0,s.du)(i)&&!(0,s.a5)(this.spatialReference,i)&&c?async e=>this._project(e,i):e=>e,h=this.featureAdapter,m=await this._reschedule((()=>this._searchFeatures(U(u))),t);if("disjoint"===e.sceneFilter.spatialRelationship){if(!m.length)return null;const i=new Set;for(const e of m)i.add(h.getObjectId(e));const s=await this._reschedule((()=>this._getAllFeatures()),t),n=await this._reschedule((async()=>{const n=await(0,a.P)("esriSpatialRelDisjoint",u,this.geometryType,this.hasZ,this.hasM),r=e=>!i.has(h.getObjectId(e))||n(h.getGeometry(e)),l=await this._runSpatialFilter(s,r,t);return new D(l,e,this)}),t);return d(n)}if(!m.length)return new D([],e,this);if(this._canExecuteSinglePass(u,e))return d(new D(m,e,this));const f=await(0,a.P)("esriSpatialRelContains",u,this.geometryType,this.hasZ,this.hasM),p=await this._runSpatialFilter(m,(e=>f(h.getGeometry(e))),t);return d(new D(p,e,this))}async _executeGeometryQuery(e,t,i){if(null!=t&&0===t.items.length)return t;e=null!=t?t.query:e;const{geometry:n,outSR:r,spatialRel:l,returnGeometry:o,returnCentroid:u}=e,c=this.featureStore.featureSpatialReference,d=!n||null==c||(0,s.a5)(c,n.spatialReference)?n:(0,s.di)(n,c),h=o||u,m=(0,s.du)(r)&&!(0,s.a5)(this.spatialReference,r),f=null==t?this._getCacheKey(e):null,p=f?this._cache.get(f):null;if(null!=p)return new D(p,e,this);const y=async e=>(m&&h&&await this._project(e,r),f&&this._cache.put(f,e.items),e);if(!d)return y(t??await this._getAllFeaturesQueryEngineResult(e));const g=this.featureAdapter;let x=await this._reschedule((()=>this._searchFeatures(U(n))),i);if("esriSpatialRelDisjoint"===l){if(!x.length)return y(t??await this._getAllFeaturesQueryEngineResult(e));const s=new Set;for(const e of x)s.add(g.getObjectId(e));const n=null!=t?t.items:await this._reschedule((()=>this._getAllFeatures()),i),r=await this._reschedule((async()=>{const t=await(0,a.P)(l,d,this.geometryType,this.hasZ,this.hasM),r=e=>!s.has(g.getObjectId(e))||t(g.getGeometry(e)),o=await this._runSpatialFilter(n,r,i);return new D(o,e,this)}),i);return y(r)}if(null!=t){const e=new s.cP;x=x.filter((i=>(0,s.cN)(t.items,i,t.items.length,e)>=0))}if(!x.length){const t=new D([],e,this);return f&&this._cache.put(f,t.items),t}if(this._canExecuteSinglePass(d,e))return y(new D(x,e,this));const F=await(0,a.P)(l,d,this.geometryType,this.hasZ,this.hasM),_=await this._runSpatialFilter(x,(e=>F(g.getGeometry(e))),i);return y(new D(_,e,this))}async _executeGeometryQueryForSnapping(e,t){const{query:i}=e,{spatialRel:s}=i;if(!e?.items?.length||!i.geometry||!s)return;const n=await(0,a.P)(s,i.geometry,this.geometryType,this.hasZ,this.hasM),r=await this._runSpatialFilter(e.items,(e=>n(e.geometry)),t);e.items=r}_executeAggregateIdsQuery(e){if(0===e.items.length||!e.query.aggregateIds?.length||null==this.aggregateAdapter)return;const t=new Set;for(const s of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach((e=>t.add(e)));const i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeObjectIdsQuery(e){if(0===e.items.length||!e.query.objectIds?.length)return;const t=new Set(e.query.objectIds),i=this.featureAdapter.getObjectId;e.items=e.items.filter((e=>t.has(i(e))))}_executeTimeQuery(e){if(0===e.items.length)return;const t=(0,a.t)(this.timeInfo,e.query.timeExtent,this.featureAdapter);null!=t&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(0===e.items.length)return;const t=F(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter((e=>t.testFeature(e,this.featureAdapter)))}}async _runSpatialFilter(e,t,i){if(!t)return e;if(null==this._frameTask)return e.filter((e=>t(e)));let s=0;const n=new Array,a=async r=>{for(;s<e.length;){const l=e[s++];t(l)&&(n.push(l),r.madeProgress()),r.done&&await this._reschedule((e=>a(e)),i)}};return this._reschedule((e=>a(e)),i).then((()=>n))}_filterLatest(e){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,n=s||i,a=new Map,r=this.featureAdapter.getAttribute;for(const l of e.items){const e=r(l,t),i=r(l,n),s=a.get(e);(!s||i>r(s,n))&&a.set(e,l)}e.items=Array.from(a.values())}_getCacheKey(e){const{geometry:t,spatialRel:i,returnGeometry:n,returnCentroid:a,outSR:r,resultType:l,cacheHint:o}=e;if("tile"!==l&&!o)return null;const u=n||a;return(0,s.du)(r)&&!(0,s.a5)(this.spatialReference,r)&&u?JSON.stringify([t,i,r]):JSON.stringify([t,i])}_canExecuteSinglePass(e,t){const{spatialRel:i}=t;return(0,a.I)(e)&&("esriSpatialRelEnvelopeIntersects"===i||"esriGeometryPoint"===this.geometryType&&("esriSpatialRelIntersects"===i||"esriSpatialRelContains"===i))}async _project(e,t){if(!t||(0,s.a5)(this.spatialReference,t))return e;const i=this.featureAdapter;let n;try{const e=await this._getFullExtent();n=(0,s.cs)(this.spatialReference,t,e)}catch{}const r=await(0,s.mF)(e.items.map((e=>(0,a.a)(this.geometryType,this.hasZ,this.hasM,i.getGeometry(e)))),this.spatialReference,t,n);return e.items=r.map(((t,n)=>i.cloneWithGeometry(e.items[n],(0,s.dh)(t,this.hasZ,this.hasM)))),e}async _searchFeatures(e){const t=new Set;await Promise.all(e.map((e=>this.featureStore.forEachInBounds(e,(e=>t.add(e))))));const i=Array.from(t.values());return t.clear(),i}async _executeQueryForStatistics(e,t,i){e=(0,s.T)(e);try{e=await this._schedule((()=>(0,s.mE)(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>Z(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference})),i);const n=await this._reschedule((()=>this._executeSceneFilterQuery(e,i)),i),a=await this._reschedule((()=>this._executeGeometryQuery(e,n,i)),i);return await this._reschedule((()=>this._executeAggregateIdsQuery(a)),i),await this._reschedule((()=>this._executeObjectIdsQuery(a)),i),await this._reschedule((()=>this._executeTimeQuery(a)),i),await this._reschedule((()=>this._executeAttributesQuery(a)),i),a}catch(n){if(n!==s.mA)throw n;return new D([],e,this)}}}function U(e){if((0,a.I)(e)){if((0,s.aN)(e))return[(0,s.dP)(Math.min(e.xmin,e.xmax),Math.min(e.ymin,e.ymax),Math.max(e.xmin,e.xmax),Math.max(e.ymin,e.ymax))];if((0,s.b8)(e))return e.rings.map((e=>(0,s.dP)(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1]))))}return[(0,s.ba)((0,s.b2)(),e)]}},94706:function(e,t,i){i.d(t,{t:function(){return s}});const s={supportsStatistics:!0,supportsPercentileStatistics:!0,supportsSpatialAggregationStatistics:!1,supportedSpatialAggregationStatistics:{envelope:!1,centroid:!1,convexHull:!1},supportsCentroid:!0,supportsCacheHint:!0,supportsDistance:!0,supportsDistinct:!0,supportsExtent:!0,supportsGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQuantization:!0,supportsQuantizationEditMode:!1,supportsQueryGeometry:!0,supportsResultType:!0,supportsSqlExpression:!0,supportsMaxRecordCountFactor:!1,supportsStandardizedQueriesOnly:!0,supportsTopFeaturesQuery:!1,supportsQueryByAnonymous:!0,supportsQueryByOthers:!0,supportsHistoricMoment:!1,supportsFormatPBF:!1,supportsDisjointSpatialRelationship:!0,supportsDefaultSpatialReference:!1,supportsFullTextSearch:!1,supportsCompactGeometry:!1,maxRecordCountFactor:void 0,maxRecordCount:void 0,standardMaxRecordCount:void 0,tileMaxRecordCount:void 0}},76775:function(e,t,i){i.d(t,{$:function(){return n},j:function(){return a}});var s=i(44444);function n(e){return(0,s.bV)(e)||(0,s.bW)(e)||(0,s.bX)(e)}function a(e,t){const{format:i,timeZoneOptions:n,fieldType:a}=t??{};let r,l;if(n&&({timeZone:r,timeZoneName:l}=(0,s.bY)(n.layerTimeZone,n.datesInUnknownTimezone,n.viewTimeZone,(0,s.bZ)(i||"short-date-short-time"),a)),"string"==typeof e&&isNaN(Date.parse("time-only"===a?`1970-01-01T${e}Z`:e)))return e;switch(a){case"date-only":{const t=(0,s.bZ)(i||"short-date");return"string"==typeof e?(0,s.c1)(e,{...t}):(0,s.av)(e,{...t,timeZone:s.c0})}case"time-only":{const t=(0,s.bZ)(i||"short-time");return"string"==typeof e?(0,s.b$)(e,t):(0,s.av)(e,{...t,timeZone:s.c0})}case"timestamp-offset":{if(!r&&"string"==typeof e&&new Date(e).toISOString()!==e)return e;const t=i||n?(0,s.bZ)(i||"short-date-short-time"):void 0,a=t?{...t,timeZone:r,timeZoneName:l}:void 0;return"string"==typeof e?(0,s.b_)(e,a):(0,s.av)(e,a)}default:{const t=i||n?(0,s.bZ)(i||"short-date-short-time"):void 0;return(0,s.av)("string"==typeof e?new Date(e):e,t?{...t,timeZone:r,timeZoneName:l}:void 0)}}}},47426:function(e,t,i){i.d(t,{I:function(){return d},b:function(){return h},w:function(){return c},x:function(){return u}});var s=i(44444),n=i(76775),a=i(59064);let r=null;const l=/^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;function o(e,t,i){return e.x<0?e.x+=t:e.x>i&&(e.x-=t),e}function u(e,t,i,n){const a=(0,s.cY)(i)?(0,s.b3)(i):null,r=a?Math.round((a.valid[1]-a.valid[0])/t.scale[0]):null;return e.map((e=>{const i=new s.D(e.geometry);return(0,s.cZ)(t,i,i),e.geometry=a?o(i,r??0,n[0]):i,e}))}function c(e,t=18,i,n,a){const r=new Float64Array(n*a);t=Math.round((0,s.d2)(t));let l=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY;const u=(0,s.d3)(i);for(const{geometry:c,attributes:d}of e){const{x:e,y:i}=c,h=Math.max(0,e-t),m=Math.max(0,i-t),f=Math.min(a,i+t),p=Math.min(n,e+t),y=+u(d);for(let a=m;a<f;a++)for(let u=h;u<p;u++){const c=a*n+u,d=(0,s.c_)(u-e,a-i,t)*y,h=r[c]+=d;l=Math.min(l,h),o=Math.max(o,h)}}return{min:l,max:o}}function d(e){const t=l.exec(e);if(!t)return null;const{hh:i,mm:n,ss:a,ms:r}=t.groups;return Number(i)*s.c$.hours+Number(n)*s.c$.minutes+Number(a)*s.c$.seconds+Number(r||0)}async function h(e,t,i=!0){if(!t)return[];const{field:l,field2:o,field3:u,fieldDelimiter:c,fieldInfos:h,timeZone:m}=e,f=l&&h?.find((e=>e.name.toLowerCase()===l.toLowerCase())),p=!!f&&(0,s.d0)(f),y=!!f&&(0,n.$)(f),g=e.valueExpression,x=e.normalizationType,F=e.normalizationField,_=e.normalizationTotal,w=[],b=e.viewInfoParams;let v=null,I=null;if(g){if(!r){const{arcadeUtils:e}=await(0,s.d1)();r=e}r.hasGeometryOperations(g)&&await r.enableGeometryOperations(),v=r.createFunction(g),I=b?r.getViewInfo({viewingMode:b.viewingMode,scale:b.scale,spatialReference:new s.aY(b.spatialReference)}):null}const S=e.fieldInfos,T=t[0]&&"declaredClass"in t[0]&&"esri.Graphic"===t[0].declaredClass||!S?null:{fields:S};return t.forEach((e=>{const t=e.attributes;let s;if(g){const t=T?{...e,layer:T}:e,i=r.createExecContext(t,I,m);s=r.executeFunction(v,i)}else t&&(s=t[l],o?(s=`${(0,a.m)(s)}${c}${(0,a.m)(t[o])}`,u&&(s=`${s}${c}${(0,a.m)(t[u])}`)):"string"==typeof s&&i&&(y?s=s?new Date(s).getTime():null:p&&(s=s?d(s):null)));if(x&&"number"==typeof s&&isFinite(s)){const e=t&&parseFloat(t[F]);s=(0,a.B)(s,x,e,_)}w.push(s)})),w}},59064:function(e,t,i){i.d(t,{$:function(){return H},B:function(){return Y},C:function(){return j},E:function(){return J},P:function(){return K},U:function(){return ee},d:function(){return V},f:function(){return R},g:function(){return M},k:function(){return U},m:function(){return T},p:function(){return z},v:function(){return A}});var s=i(44444);const n=()=>s.G.getLogger("esri.rest.support.generateRendererUtils");function a(e,t){return Number(e.toFixed(t))}function r(e){const{normalizationTotal:t}=e;return{classBreaks:l(e),normalizationTotal:t}}function l(e){const t=e.definition,{classificationMethod:i,normalizationType:s,definedInterval:n}=t,r=t.breakCount??1,l=[];let d=e.values;if(0===d.length)return[];d=d.sort(((e,t)=>e-t));const h=d[0],y=d[d.length-1];if("equal-interval"===i)if(d.length>=r){const e=(y-h)/r;let t=h;for(let i=1;i<r;i++){const n=a(h+i*e,6);l.push({minValue:t,maxValue:n,label:o(t,n,s)}),t=n}l.push({minValue:t,maxValue:y,label:o(t,y,s)})}else d.forEach((e=>{l.push({minValue:e,maxValue:e,label:o(e,e,s)})}));else if("natural-breaks"===i){const t=u(d),i=e.valueFrequency||t.valueFrequency,n=c(t.uniqueValues,i,r);let m=h;for(let e=1;e<r;e++)if(t.uniqueValues.length>e){const i=a(t.uniqueValues[n[e]],6);l.push({minValue:m,maxValue:i,label:o(m,i,s)}),m=i}l.push({minValue:m,maxValue:y,label:o(m,y,s)})}else if("quantile"===i)if(d.length>=r&&h!==y){let e=h,t=Math.ceil(d.length/r),i=0;for(let n=1;n<r;n++){let a=t+i-1;a>d.length&&(a=d.length-1),a<0&&(a=0),l.push({minValue:e,maxValue:d[a],label:o(e,d[a],s)}),e=d[a],i+=t,t=Math.ceil((d.length-i)/(r-n))}l.push({minValue:e,maxValue:y,label:o(e,y,s)})}else{let e=-1;for(let t=0;t<d.length;t++){const i=d[t];i!==e&&(e=i,l.push({minValue:e,maxValue:i,label:o(e,i,s)}),e=i)}}else if("standard-deviation"===i){const e=f(d),t=p(d,e);if(0===t)l.push({minValue:d[0],maxValue:d[0],label:o(d[0],d[0],s)});else{const i=m(h,y,r,e,t)*t;let n=0,u=h;for(let t=r;t>=1;t--){const r=a(e-(t-.5)*i,6);l.push({minValue:u,maxValue:r,label:o(u,r,s)}),u=r,n++}let c=a(e+.5*i,6);l.push({minValue:u,maxValue:c,label:o(u,c,s)}),u=c,n++;for(let t=1;t<=r;t++)c=n===2*r?y:a(e+(t+.5)*i,6),l.push({minValue:u,maxValue:c,label:o(u,c,s)}),u=c,n++}}else if("defined-interval"===i){if(!n)return l;const e=d[0],t=d[d.length-1],i=Math.ceil((t-e)/n);let r=e;for(let u=1;u<i;u++){const t=a(e+u*n,6);l.push({minValue:r,maxValue:t,label:o(r,t,s)}),r=t}l.push({minValue:r,maxValue:t,label:o(r,t,s)})}return l}function o(e,t,i){let s=null;return s=e===t?i&&"percent-of-total"===i?e+"%":e.toString():i&&"percent-of-total"===i?e+"% - "+t+"%":e+" - "+t,s}function u(e){const t=[],i=[];let s=Number.MIN_VALUE,n=1,a=-1;for(let r=0;r<e.length;r++){const l=e[r];l===s?(n++,i[a]=n):null!==l&&(t.push(l),s=l,n=1,i.push(n),a++)}return{uniqueValues:t,valueFrequency:i}}function c(e,t,i){const s=e.length,n=[];i>s&&(i=s);for(let r=0;r<i;r++)n.push(Math.round(r*s/i-1));n.push(s-1);let a=d(n,e,t,i);return h(a.mean,a.sdcm,n,e,t,i)&&(a=d(n,e,t,i)),n}function d(e,t,i,s){let n=[],a=[],r=[],l=0;const o=[],u=[];for(let m=0;m<s;m++){const s=y(m,e,t,i);o.push(s.sbMean),u.push(s.sbSdcm),l+=u[m]}let c,d=l,h=!0;for(;h||l<d;){h=!1,n=[];for(let t=0;t<s;t++)n.push(e[t]);for(let i=0;i<s;i++)for(let n=e[i]+1;n<=e[i+1];n++)if(c=t[n],i>0&&n!==e[i+1]&&Math.abs(c-o[i])>Math.abs(c-o[i-1]))e[i]=n;else if(i<s-1&&e[i]!==n-1&&Math.abs(c-o[i])>Math.abs(c-o[i+1])){e[i+1]=n-1;break}d=l,l=0,a=[],r=[];for(let n=0;n<s;n++){a.push(o[n]),r.push(u[n]);const s=y(n,e,t,i);o[n]=s.sbMean,u[n]=s.sbSdcm,l+=u[n]}}if(l>d){for(let t=0;t<s;t++)e[t]=n[t],o[t]=a[t],u[t]=r[t];l=d}return{mean:o,sdcm:u}}function h(e,t,i,s,n,a){let r=0,l=0,o=0,u=0,c=!0;for(let d=0;d<2&&c;d++){0===d&&(c=!1);for(let d=0;d<a-1;d++)for(;i[d+1]+1!==i[d+2];){i[d+1]=i[d+1]+1;const a=y(d,i,s,n);o=a.sbMean,r=a.sbSdcm;const h=y(d+1,i,s,n);if(u=h.sbMean,l=h.sbSdcm,!(r+l<t[d]+t[d+1])){i[d+1]=i[d+1]-1;break}t[d]=r,t[d+1]=l,e[d]=o,e[d+1]=u,c=!0}for(let d=a-1;d>0;d--)for(;i[d]!==i[d-1]+1;){i[d]=i[d]-1;const a=y(d-1,i,s,n);o=a.sbMean,r=a.sbSdcm;const h=y(d,i,s,n);if(u=h.sbMean,l=h.sbSdcm,!(r+l<t[d-1]+t[d])){i[d]=i[d]+1;break}t[d-1]=r,t[d]=l,e[d-1]=o,e[d]=u,c=!0}}return c}function m(e,t,i,s,n){let a=Math.max(s-e,t-s)/n/i;return a=a>=1?1:a>=.5?.5:.25,a}function f(e){let t=0;for(let i=0;i<e.length;i++)t+=e[i];return t/=e.length,t}function p(e,t){let i=0;for(let s=0;s<e.length;s++){const n=e[s];i+=(n-t)*(n-t)}return i/=e.length,Math.sqrt(i)}function y(e,t,i,s){let a=0,r=0;for(let n=t[e]+1;n<=t[e+1];n++){const e=s[n];a+=i[n]*e,r+=e}r<=0&&n().warn("Exception in Natural Breaks calculation");const l=a/r;let o=0;for(let n=t[e]+1;n<=t[e+1];n++)o+=s[n]*(i[n]-l)**2;return{sbMean:l,sbSdcm:o}}const g="<Null>",x="equal-interval",F=1,_=5,w=10,b=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,v=new Set(["esriFieldTypeDate","esriFieldTypeInteger","esriFieldTypeSmallInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeOID","esriFieldTypeBigInteger"]),I=new Set(["esriFieldTypeTimeOnly","esriFieldTypeDateOnly"]),S=["min","max","avg","stddev","count","sum","variance","nullcount","median"];function T(e){return null==e||"string"==typeof e&&!e?g:e}function V(e){const t=null!=e.normalizationField||null!=e.normalizationType,i=null!=e.minValue||null!=e.maxValue,s=!!e.sqlExpression&&e.supportsSQLExpression;return!t&&!i&&!s}function R(e){const{outStatisticTypes:t}=e,i=e.returnDistinct?[...new Set(e.values)]:e.values,s=i.filter((e=>null!=e)).sort(),n=s.length,a={count:n,min:s[0],max:s[n-1]};return e.supportsNullCount&&(a.nullcount=i.length-n),!e.percentileParams||t?.include?.length&&!t.include.includes("median")||t?.exclude?.length&&t.exclude.includes("median")||(a.median=A(i,e.percentileParams)),a}function z(e){const{values:t,useSampleStdDev:i,supportsNullCount:s,outStatisticTypes:n}=e;let a=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,l=null,o=null,u=null,c=null,d=0;const h=null==e.minValue?-1/0:e.minValue,m=null==e.maxValue?1/0:e.maxValue;for(const p of t)Number.isFinite(p)?p>=h&&p<=m&&(l=null===l?p:l+p,a=Math.min(a,p),r=Math.max(r,p),d++):"string"==typeof p&&d++;if(d&&null!=l){o=l/d;let e=0;for(const i of t)Number.isFinite(i)&&i>=h&&i<=m&&(e+=(i-o)**2);c=i?d>1?e/(d-1):0:d>0?e/d:0,u=Math.sqrt(c)}else a=null,r=null;const f={avg:o,count:d,max:r,min:a,stddev:u,sum:l,variance:c};return s&&(f.nullcount=t.length-d),!e.percentileParams||n?.include?.length&&!n.include.includes("median")||n?.exclude?.length&&n.exclude.includes("median")||(f.median=A(t,e.percentileParams)),f}function A(e,t){const{fieldType:i,value:s,orderBy:n,isDiscrete:a}=t,r=M(i,"desc"===n);if(0===(e=[...e].filter((e=>null!=e)).sort(((e,t)=>r(e,t)))).length)return null;if(s<=0)return e[0];if(s>=1)return e[e.length-1];const l=(e.length-1)*s,o=Math.floor(l),u=o+1,c=l%1,d=e[o],h=e[u];return u>=e.length||a||"string"==typeof d||"string"==typeof h?d:d*(1-c)+h*c}function M(e,t){if(e){if(v.has(e))return B(t);if(I.has(e))return O(t,!1);if("esriFieldTypeTimestampOffset"===e)return P(t);const i=O(t,!0);if("esriFieldTypeString"===e)return i;if("esriFieldTypeGUID"===e||"esriFieldTypeGlobalID"===e)return(e,t)=>i($(e),$(t))}const i=t?1:-1,s=B(t),n=O(t,!0),a=C(t);return(e,t)=>"number"==typeof e&&"number"==typeof t?s(e,t):"string"==typeof e&&"string"==typeof t?n(e,t):a(e,t)??i}const D=(e,t)=>null==e?null==t?0:1:null==t?-1:null,E=(e,t)=>null==e?null==t?0:-1:null==t?1:null;function C(e){return e?D:E}const N=(e,t)=>E(e,t)??(e===t?0:new Date(e).getTime()-new Date(t).getTime()),q=(e,t)=>D(e,t)??(e===t?0:new Date(t).getTime()-new Date(e).getTime());function P(e){return e?q:N}const Q=(e,t)=>E(e,t)??(e===t?0:e<t?-1:1),G=(e,t)=>D(e,t)??(e===t?0:e<t?1:-1);function O(e,t){if(!t)return e?G:Q;const i=C(e);return e?(e,t)=>i(e,t)??((e=e.toUpperCase())>(t=t.toUpperCase())?-1:e<t?1:0):(e,t)=>i(e,t)??((e=e.toUpperCase())<(t=t.toUpperCase())?-1:e>t?1:0)}const Z=(e,t)=>D(e,t)??t-e,k=(e,t)=>E(e,t)??e-t;function B(e){return e?Z:k}function $(e){return e.slice(24,36)+e.slice(19,23)+e.slice(16,18)+e.slice(14,16)+e.slice(11,13)+e.slice(9,11)+e.slice(6,8)+e.slice(4,6)+e.slice(2,4)+e.slice(0,2)}function j(e,t,i){let s;for(s in e)t?.include?.length&&!t.include.includes(s)||t?.exclude?.length&&t.exclude.includes(s)?delete e[s]:S.includes(s)&&(Number.isFinite(e[s])||(e[s]=null));return i&&["avg","stddev","variance"].forEach((t=>{null!=e[t]&&(e[t]=Math.ceil(e[t]??0))})),e}function U(e){const t={};for(let i of e)(null==i||"string"==typeof i&&""===i.trim())&&(i=null),null==t[i]?t[i]={count:1,data:i}:t[i].count++;return{count:t}}function L(e){return"coded-value"!==e?.type?[]:e.codedValues.map((e=>e.code))}function H(e,t,i,s){const n=e.count,a=[];if(i&&t){const e=[],i=L(t[0]);for(const n of i)if(t[1]){const i=L(t[1]);for(const a of i)if(t[2]){const i=L(t[2]);for(const t of i)e.push(`${T(n)}${s}${T(a)}${s}${T(t)}`)}else e.push(`${T(n)}${s}${T(a)}`)}else e.push(n);for(const t of e)n.hasOwnProperty(t)||(n[t]={data:t,count:0})}for(const r in n){const e=n[r];a.push({value:e.data,count:e.count,label:e.label})}return{uniqueValueInfos:a}}function Y(e,t,i,s){let n=null;switch(t){case"log":0!==e&&(n=Math.log(e)*Math.LOG10E);break;case"percent-of-total":Number.isFinite(s)&&0!==s&&(n=e/s*100);break;case"field":Number.isFinite(i)&&0!==i&&(n=e/i);break;case"natural-log":e>0&&(n=Math.log(e));break;case"square-root":e>0&&(n=e**.5)}return n}function J(e,t){const i=X({field:t.field,normalizationType:t.normalizationType,normalizationField:t.normalizationField,classificationMethod:t.classificationMethod,standardDeviationInterval:t.standardDeviationInterval,breakCount:t.numClasses||_});return e=W(e,t.minValue,t.maxValue),r({definition:i,values:e,normalizationTotal:t.normalizationTotal})}function W(e,t,i){const s=t??-1/0,n=i??1/0;return e.filter((e=>Number.isFinite(e)&&e>=s&&e<=n))}function X(e){const{breakCount:t,field:i,normalizationField:n,normalizationType:a}=e,r=e.classificationMethod||x,l="standard-deviation"===r?e.standardDeviationInterval||F:void 0,o="defined-interval"===r?e.definedInterval:void 0;return new s.h6({breakCount:t,classificationField:i,classificationMethod:r,normalizationField:"field"===a?n:void 0,normalizationType:a,standardDeviationInterval:l,definedInterval:o})}function K(e,t){let i=e.classBreaks;const s=i.length,n=i[0]?.minValue,a=i[s-1]?.maxValue,r="standard-deviation"===t,l=b;return i=i.map((e=>{const t=e.label,i={minValue:e.minValue,maxValue:e.maxValue,label:t};if(r&&t){const e=t.match(l),s=e?.map((e=>+e.trim()))??[];2===s.length?(i.minStdDev=s[0],i.maxStdDev=s[1],s[0]<0&&s[1]>0&&(i.hasAvg=!0)):1===s.length&&(t.includes("<")?(i.minStdDev=null,i.maxStdDev=s[0]):t.includes(">")&&(i.minStdDev=s[0],i.maxStdDev=null))}return i})),{minValue:n,maxValue:a,classBreakInfos:i,normalizationTotal:e.normalizationTotal}}function ee(e,t){const i=te(e,t);if(null==i.min&&null==i.max)return{bins:[],minValue:i.min,maxValue:i.max,normalizationTotal:t.normalizationTotal};const s=i.intervals,n=i.min??0,a=i.max??0,r=s.map(((e,t)=>({minValue:s[t][0],maxValue:s[t][1],count:0})));for(const l of e)if(null!=l&&l>=n&&l<=a){const e=ie(s,l);e>-1&&r[e].count++}return{bins:r,minValue:n,maxValue:a,normalizationTotal:t.normalizationTotal}}function te(e,t){const{field:i,classificationMethod:s,standardDeviationInterval:n,normalizationType:a,normalizationField:r,normalizationTotal:l,minValue:o,maxValue:u}=t,c=t.numBins||w;let d=null,h=null,m=null;if(s&&"equal-interval"!==s||a){const{classBreaks:t}=J(e,{field:i,normalizationType:a,normalizationField:r,normalizationTotal:l,classificationMethod:s,standardDeviationInterval:n,minValue:o,maxValue:u,numClasses:c});d=t[0].minValue,h=t[t.length-1].maxValue,m=t.map((e=>[e.minValue,e.maxValue]))}else{if(null!=o&&null!=u)d=o,h=u;else{const t=z({values:e,minValue:o,maxValue:u,useSampleStdDev:!a,supportsNullCount:V({normalizationType:a,normalizationField:r,minValue:o,maxValue:u})});d=t.min??null,h=t.max??null}m=se(d??0,h??0,c)}return{min:d,max:h,intervals:m}}function ie(e,t){let i=-1;for(let s=e.length-1;s>=0;s--)if(t>=e[s][0]){i=s;break}return i}function se(e,t,i){const s=(t-e)/i,n=[];let a,r=e;for(let l=1;l<=i;l++)a=r+s,a=Number(a.toFixed(16)),n.push([r,l===i?t:a]),r=a;return n}}}]);
//# sourceMappingURL=5599.894bc97a.js.map