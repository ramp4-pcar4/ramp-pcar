"use strict";(self["webpackChunkramp_website"]=self["webpackChunkramp_website"]||[]).push([[8660],{98660:function(n,t,e){e.r(t),e.d(t,{buffer:function(){return E},changeDefaultSpatialReferenceTolerance:function(){return X},clearDefaultSpatialReferenceTolerance:function(){return Y},clip:function(){return y},contains:function(){return d},convexHull:function(){return N},crosses:function(){return m},cut:function(){return w},densify:function(){return _},difference:function(){return k},disjoint:function(){return A},distance:function(){return g},equals:function(){return h},extendedSpatialReferenceInfo:function(){return p},flipHorizontal:function(){return q},flipVertical:function(){return B},generalize:function(){return G},geodesicArea:function(){return M},geodesicBuffer:function(){return z},geodesicDensify:function(){return W},geodesicLength:function(){return Q},intersect:function(){return L},intersectLinesToPoints:function(){return U},intersects:function(){return S},isSimple:function(){return b},nearestCoordinate:function(){return C},nearestVertex:function(){return H},nearestVertices:function(){return I},offset:function(){return V},overlaps:function(){return D},planarArea:function(){return F},planarLength:function(){return K},relate:function(){return O},rotate:function(){return j},simplify:function(){return J},symmetricDifference:function(){return v},touches:function(){return R},union:function(){return T},within:function(){return x}});var r=e(44444);function i(n){return Array.isArray(n)?n[0]?.spatialReference:n?.spatialReference}function u(n){return n&&(Array.isArray(n)?n.map(u):n.toJSON?n.toJSON():n)}function c(n){return Array.isArray(n)?n.map((n=>(0,r.f1)(n))):(0,r.f1)(n)}function a(n,t){let e;return Array.isArray(n)?e=n:(e=[],e.push(n),null!=t&&e.push(t)),e}let o;async function f(){return o||(o=(0,r.f2)("geometryEngineWorker",{strategy:"distributed"})),o}async function s(n,t){return(await f()).invoke("executeGEOperation",{operation:n,parameters:u(t)})}async function l(n,t){const e=await f();return Promise.all(e.broadcast("executeGEOperation",{operation:n,parameters:u(t)}))}function p(n){return s("extendedSpatialReferenceInfo",[n])}async function y(n,t){return c(await s("clip",[i(n),n,t]))}async function w(n,t){return c(await s("cut",[i(n),n,t]))}function d(n,t){return s("contains",[i(n),n,t])}function m(n,t){return s("crosses",[i(n),n,t])}function g(n,t,e){return s("distance",[i(n),n,t,e])}function h(n,t){return s("equals",[i(n),n,t])}function S(n,t){return s("intersects",[i(n),n,t])}function R(n,t){return s("touches",[i(n),n,t])}function x(n,t){return s("within",[i(n),n,t])}function A(n,t){return s("disjoint",[i(n),n,t])}function D(n,t){return s("overlaps",[i(n),n,t])}function O(n,t,e){return s("relate",[i(n),n,t,e])}function b(n){return s("isSimple",[i(n),n])}async function J(n){return c(await s("simplify",[i(n),n]))}async function N(n,t=!1){return c(await s("convexHull",[i(n),n,t]))}async function k(n,t){return c(await s("difference",[i(n),n,t]))}async function v(n,t){return c(await s("symmetricDifference",[i(n),n,t]))}async function L(n,t){return c(await s("intersect",[i(n),n,t]))}async function T(n,t=null){const e=a(n,t);return c(await s("union",[i(e),e]))}async function V(n,t,e,r,u,a){return c(await s("offset",[i(n),n,t,e,r,u,a]))}async function E(n,t,e,r=!1){const u=[i(n),n,t,e,r];return c(await s("buffer",u))}async function z(n,t,e,r,u,a){const o=[i(n),n,t,e,r,u,a];return c(await s("geodesicBuffer",o))}async function C(n,t,e=!0){const u=await s("nearestCoordinate",[i(n),n,t,e]);return{...u,coordinate:r.D.fromJSON(u.coordinate)}}async function H(n,t){const e=await s("nearestVertex",[i(n),n,t]);return{...e,coordinate:r.D.fromJSON(e.coordinate)}}async function I(n,t,e,u){return(await s("nearestVertices",[i(n),n,t,e,u])).map((n=>({...n,coordinate:r.D.fromJSON(n.coordinate)})))}function P(n){return"xmin"in n?n.center:"x"in n?n:n.extent?.center}async function j(n,t,e){if(null==n)throw new Z;const r=n.spatialReference;if(null==(e=e??P(n)))throw new Z;const i=n.constructor.fromJSON(await s("rotate",[r,n,t,e]));return i.spatialReference=r,i}async function q(n,t){if(null==n)throw new Z;const e=n.spatialReference;if(null==(t=t??P(n)))throw new Z;const r=n.constructor.fromJSON(await s("flipHorizontal",[e,n,t]));return r.spatialReference=e,r}async function B(n,t){if(null==n)throw new Z;const e=n.spatialReference;if(null==(t=t??P(n)))throw new Z;const r=n.constructor.fromJSON(await s("flipVertical",[e,n,t]));return r.spatialReference=e,r}async function G(n,t,e,r){return c(await s("generalize",[i(n),n,t,e,r]))}async function _(n,t,e){return c(await s("densify",[i(n),n,t,e]))}async function W(n,t,e,r=0){return c(await s("geodesicDensify",[i(n),n,t,e,r]))}function F(n,t){return s("planarArea",[i(n),n,t])}function K(n,t){return s("planarLength",[i(n),n,t])}function M(n,t,e){return s("geodesicArea",[i(n),n,t,e])}function Q(n,t,e){return s("geodesicLength",[i(n),n,t,e])}async function U(n,t){return c(await s("intersectLinesToPoints",[i(n),n,t]))}async function X(n,t){await l("changeDefaultSpatialReferenceTolerance",[n,t])}async function Y(n){await l("clearDefaultSpatialReferenceTolerance",[n])}class Z extends Error{constructor(){super("Illegal Argument Exception")}}}}]);
//# sourceMappingURL=8660.79a096a3.js.map