"use strict";(self["webpackChunkramp_website"]=self["webpackChunkramp_website"]||[]).push([[9868],{79868:function(e,t,s){s.d(t,{j:function(){return $},r:function(){return N}});var i=s(81298),r=s(44444),n=s(52576),o=s(63643),a=s(31061),c=s(13444),l=s(28326);let h=class extends n.c{};function u(e){const{sprite:t,isMapAligned:s,colorLocked:r,scaleSymbolsProportionally:o,isStroke:a}=e;let c=0;return s&&(c|=(0,n.f)(i.o.bitset.isMapAligned)),r&&(c|=(0,n.f)(i.o.bitset.colorLocked)),t.sdf&&(c|=(0,n.f)(i.o.bitset.isSDF)),o&&(c|=(0,n.f)(i.o.bitset.scaleSymbolsProportionally)),a&&(c|=(0,n.f)(i.o.bitset.isStroke)),c}let d=class extends h{get vertexSpec(){return{createComputedParams:e=>{let{pixelDimensions:t,texelDimensions:s,baseSize:i,referenceSize:n,strokeWidth:o,sizeRatio:a}=e;t||(t=e.sprite.sdf?[0,0]:[e.sprite.width,e.sprite.height]),s||(s=e.sprite.sdf?[0,0]:t),i=(0,r.d2)(i),n=(0,r.d2)(n),o=(0,r.d2)(o);const c=(e.sprite.sdfDecodeCoeff??1)*a;return{...e,pixelDimensions:t,texelDimensions:s,baseSize:i,referenceSize:n,strokeWidth:o,sdfDecodeCoeff:c}},optionalAttributes:{zoomRange:{type:r.aC.SHORT,count:2,packPrecisionFactor:r.na,pack:({scaleInfo:e},{tileInfo:t})=>(0,n.m)(e,t)}},attributes:{id:{type:r.aC.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:r.aC.UNSIGNED_BYTE,count:1,pack:u},pos:{type:r.aC.SHORT,count:2,pack:"position",packPrecisionFactor:1},offset:{type:r.aC.FLOAT,count:2,packAlternating:{count:4,pack:e=>{const t=e.texelDimensions;return[[-.5*t[0],-.5*t[1]],[.5*t[0],-.5*t[1]],[-.5*t[0],.5*t[1]],[.5*t[0],.5*t[1]]]}}},uv:{type:r.aC.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:e,texXmin:t,texYmax:s,texYmin:i})=>[[t,i],[e,i],[t,s],[e,s]]}},animationPointerAndBaseSizeAndReferenceSize:{type:r.aC.UNSIGNED_SHORT,count:4,packPrecisionFactor:1,pack:({animations:e,baseSize:t,referenceSize:s})=>[e.dataColumn,e.dataRow,t,s]},sizing:{type:r.aC.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:e,pixelDimensions:t,baseSize:s,sprite:i,sizeRatio:r})=>{const n=Math.max(s*i.width/i.height,s),o=i.sdfDecodeCoeff*n*r;return[t[0],t[1],e,o]}},angle:{type:r.aC.BYTE,count:1,packTessellation:({angle:e})=>e}}}}_write(e,t){const s=this.evaluatedMeshParams.sprite,{textureBinding:r}=s;e.recordStart(this.instanceId,this.attributeLayout,r);const n=t.getDisplayId();if("esriGeometryPolygon"===t.geometryType){const s=t.readCentroidForDisplay();if(!s)return;const[i,r]=s.coords;this._writeQuad(e,n,i,r)}else if("esriGeometryPoint"===t.geometryType){const s=t.readXForDisplay(),i=t.readYForDisplay();this._writeQuad(e,n,s,i)}else{const s=t.readGeometryForDisplay();if(s){const{angleToLine:t}=this.evaluatedMeshParams;if(t){let t=!0,r=null,o=null;s.forEachVertex(((s,a)=>{if(null!=r&&null!=o){const c=Math.atan2(a-o,s-r)/i.n;t&&(this._writeQuad(e,n,r,o,c),t=!1),this._writeQuad(e,n,s,a,c)}r=s,o=a}))}else s.forEachVertex(((t,s)=>{this._writeQuad(e,n,t,s)}))}}e.recordEnd()}_writeQuad(e,t,s,i,r=0){const n=this.evaluatedMeshParams.sprite,{rect:o}=n,a=o.x+2,c=o.y+2,l=o.x+o.width-2,h=o.y+o.height-2,u=e.vertexCount();e.recordBounds(s,i,64,64);const d={texXmin:a,texYmin:c,texXmax:l,texYmax:h,angle:r};for(let f=0;f<4;f++)this._writeVertex(e,t,s,i,d);e.indexEnsureSize(6),e.indexWrite(u),e.indexWrite(u+1),e.indexWrite(u+2),e.indexWrite(u+1),e.indexWrite(u+3),e.indexWrite(u+2)}};function f(e,t,s){return e[0]=t[0]-s[0],e[1]=t[1]-s[1],e}function m(e,t){return Math.sqrt(e*e+t*t)}function p(e){const t=m(e[0],e[1]);e[0]/=t,e[1]/=t}function _(e,t){return m(e[0]-t[0],e[1]-t[1])}function g(e,t){return e[t+1]}function y(e){return e.length-1}function x(e){let t=0;for(let s=0;s<y(e);s++)t+=v(e,s);return t}function v(e,t,s=1){let[i,r]=g(e,t);return[i,r]=[Math.round(i),Math.round(r)],Math.sqrt(i*i+r*r)*s}let M=class e{constructor(e,t,s,i,r){this._segments=e,this._index=t,this._distance=s,this._xStart=i,this._yStart=r,this._done=!1}static create(t){return new e(t,0,0,t[0][0],t[0][1])}clone(){return new e(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(0===this._distance||1===e._distance)||e._index===this._index+1&&(1===this._distance||0===e._distance)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length);let s=Math.acos(t);return e>0&&(s=2*Math.PI-s),s}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<y(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){const s=this.backwardLength;if(e<=s)return this._distance=(s-e)/this.length,this;let i=this.backwardLength;for(;this.prev();){if(i+this.length>e)return this._seekBackwards(e-i);i+=this.length}return this._distance=0,t?this:null}seek(e,t=!1){if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let s=this.remainingLength;for(;this.next();){if(s+this.length>e)return this.seek(e-s,t);s+=this.length}return this._distance=1,t?this:null}};function P(e,t,s,i=!0){const r=x(e),n=M.create(e),o=r/2;if(!i)return n.seek(o),void(Math.abs(n.x)<a.e&&Math.abs(n.y)<a.e&&s(n.clone(),0,o+0*t,r));const c=Math.max((r-t)/2,0),l=Math.floor(c/t),h=o-l*t;n.seek(h);for(let u=-l;u<=l;u++)Math.abs(n.x)<a.e&&Math.abs(n.y)<a.e&&s(n.clone(),u,o+u*t,r),n.seek(t)}function b(e,t){const s=t;for(let i=0;i<e.length;i++){let t=e[i];w(t,s);const r=[];r.push(t[0]);for(let e=1;e<t.length;e++){const[s,i]=t[e-1],[n,o]=t[e],a=n-s,c=o-i;r.push([a,c])}e[i]=r,t=r}return e}function w(e,t){if(t<=0)return;const s=e.length;if(s<3)return;const i=[];let r=0;i.push(0);for(let h=1;h<s;h++)r+=_(e[h],e[h-1]),i.push(r);t=Math.min(t,.2*r);const n=[];n.push(e[0][0]),n.push(e[0][1]);const o=e[s-1][0],a=e[s-1][1],c=f([0,0],e[0],e[1]);p(c),e[0][0]+=t*c[0],e[0][1]+=t*c[1],f(c,e[s-1],e[s-2]),p(c),e[s-1][0]+=t*c[0],e[s-1][1]+=t*c[1];for(let h=1;h<s;h++)i[h]+=t;i[s-1]+=t;const l=.5*t;for(let h=1;h<s-1;h++){let r=0,o=0,a=0;for(let s=h-1;s>=0&&!(i[s+1]<i[h]-l);s--){const n=l+i[s+1]-i[h],c=i[s+1]-i[s],u=i[h]-i[s]<l?1:n/c;if(Math.abs(u)<1e-6)break;const d=u*u,f=u*n-.5*d*c,m=u*c/t,p=e[s+1],_=e[s][0]-p[0],g=e[s][1]-p[1];r+=m/f*(p[0]*u*n+.5*d*(n*_-c*p[0])-d*u*c*_/3),o+=m/f*(p[1]*u*n+.5*d*(n*g-c*p[1])-d*u*c*g/3),a+=m}for(let n=h+1;n<s&&!(i[n-1]>i[h]+l);n++){const s=l-i[n-1]+i[h],c=i[n]-i[n-1],u=i[n]-i[h]<l?1:s/c;if(Math.abs(u)<1e-6)break;const d=u*u,f=u*s-.5*d*c,m=u*c/t,p=e[n-1],_=e[n][0]-p[0],g=e[n][1]-p[1];r+=m/f*(p[0]*u*s+.5*d*(s*_-c*p[0])-d*u*c*_/3),o+=m/f*(p[1]*u*s+.5*d*(s*g-c*p[1])-d*u*c*g/3),a+=m}n.push(r/a),n.push(o/a)}n.push(o),n.push(a);for(let h=0,u=0;h<s;h++)e[h][0]=n[u++],e[h][1]=n[u++]}const I=1,S=0,k=128,A=(0,r.ni)((e=>{let t=0;if(0===e)return 1/0;for(;!(e%2);)t++,e/=2;return t}));class L extends n.N{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,s,i){if(this._zoomLevel=i||0,null!=s)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),i=t.readYForDisplay();this._writePoint(e,s,i,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":case"esriGeometryMultipoint":{const s=t.readCentroidForDisplay();if(!s)return;const[i,r]=s.coords;this._writePoint(e,i,r,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_createLineLabelMetric(e,t,s,r){const n=(0,i.f)(e),a="right"===this.evaluatedMeshParams.horizontalAlignment?-1:1,c="bottom"===this.evaluatedMeshParams.verticalAlignment?-1:1,l=this.evaluatedMeshParams.scaleInfo?.maxScale??0,h=this.evaluatedMeshParams.scaleInfo?.minScale??0;return new o.r(n,t,s,a,c,l,h,r??null)}_writePoint(e,t,s,r){const n=this._getShaping();if(!n)return;const a=r.getDisplayId(),c=(0,i.p)(this.evaluatedMeshParams.horizontalAlignment),l=(0,i.q)(this.evaluatedMeshParams.verticalAlignment),h=this.evaluatedMeshParams.scaleInfo?.maxScale??0,u=this.evaluatedMeshParams.scaleInfo?.minScale??0,d=(0,i.f)(r.getDisplayId()),f=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new o.r(d,t,s,c,l,h,u,f)),this._writeGlyphs(e,a,t,s,n,0,f),e.metricBoxWrite(n.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:s,verticalAlignment:i}=this.evaluatedMeshParams,r=this.evaluatedMeshParams.repeatLabelDistance||128,o=this._getShaping("middle");if(!o)return;const a=(e,t,s,i)=>this._placeSubdivGlyphs(e,t,s,i),c=(o.bounds.width+r)/(1<<I);this._current={out:e,id:t.getDisplayId(),shaping:o,zoomRange:(0,n.m)(s,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null},this._verticalPlacement="bottom"===i?"above":"top"===i?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,a,c):this._writeCenterAlong(t,a,c)}_writeAboveAndBelowAlong(e,t,s){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:n}=this._current,o=n.bounds.halfHeight,a=e.readGeometryForDisplay();if(!a)return;const c=new r.d9;(0,r.lq)(c,a,!1,!1,"esriGeometryPolyline",1);const l=z(new r.d9,c,o),h=z(new r.d9,c,-o),u=(0,r.dj)(h,"esriGeometryPolyline",!1,!1),d=(0,r.dj)(l,"esriGeometryPolyline",!1,!1),f=b(d.paths,n.bounds.width),m=b(u.paths,n.bounds.width);this._current.offsetDirection="above";for(const r of f)P(r,s,t,!!i);this._current.offsetDirection="below";for(const r of m)P(r,s,t,!!i)}_writeCenterAlong(e,t,s){const{repeatLabel:i}=this.evaluatedMeshParams,{shaping:r}=this._current,n=b(e.readLegacyGeometryForDisplay().paths,r.bounds.width);for(const o of n)P(o,s,t,!!i)}_placeSubdivGlyphs(e,t,s,i){const{allowOverrun:r,labelPosition:o,repeatLabelDistance:a}=this.evaluatedMeshParams,c=this._current.zoomRange[0],l=A(t),h=this._current.shaping.bounds.width/(1<<I),u=Math.sqrt(a||k)/(1<<I),d=Math.min(s,i-s),f=this._current.shaping.isMultiline?n.P:Math.log2(d/(u+h/2)),m=0===t?f:Math.min(l,f),p=Math.max(c,this._zoomLevel+I-m),_=this._zoomLevel-p,g=this._current.shaping.bounds.width/2*2**_;this._current.shaping.isMultiline?0===t&&this._placeStraight(e,p):r&&_<0?this._placeStraightAlong(e,c):"parallel"===o?this._placeStraightAlong(e,p):"curved"===o&&this._placeCurved(e,p,g)}_placeStraight(e,t){const{out:s,id:i,shaping:r,referenceBounds:n}=this._current,{x:o,y:a}=e;s.metricStart(this._createLineLabelMetric(i,o,a)),s.metricBoxWrite(r.boundsT);const c=e.angle*(180/Math.PI)%360,l=(e.angle*(180/Math.PI)+180)%360;this._writeGlyphs(s,i,o,a,r,0,n,{clipAngle:c,mapAligned:!0,isLineLabel:!0,minZoom:t}),this._writeGlyphs(s,i,o,a,r,0,n,{clipAngle:l,mapAligned:!0,isLineLabel:!0,minZoom:t}),s.metricEnd()}_placeCurved(e,t,s){const{out:i,id:r}=this._current;i.metricStart(this._createLineLabelMetric(r,e.x,e.y));const n=e.clone(),o=e.angle*(180/Math.PI)%360,a=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(n,t,1,o),this._placeBack(e,n,t,s,1,o),this._placeForward(e,n,t,s,1,o)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(n,t,0,a),this._placeBack(e,n,t,s,0,a),this._placeForward(e,n,t,s,0,a)),i.metricEnd()}_placeStraightAlong(e,t){const{out:s,id:i,shaping:o,zoomRange:a,referenceBounds:c}=this._current,{boxBorderLineColor:l,boxBackgroundColor:h}=this.evaluatedMeshParams,u=e.clone(),d=e.angle*(180/Math.PI)%360,f=(e.angle*(180/Math.PI)+180)%360,m=o.glyphs.length>0&&!(!l&&!h);if(s.metricStart(this._createLineLabelMetric(i,e.x,e.y)),m){const l=Math.max(t,a[0],0),h=Math.min(n.P,a[1]),u=(0,r.nb)((0,r.nc)(),-e.angle),m={minZoom:l,maxZoom:h,clipAngle:d,mapAligned:!0,isLineLabel:!0},p=(0,r.d2)(this.evaluatedMeshParams.offsetX),_=(0,r.d2)(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const t=(0,r.gC)(p,-1*_),[n,a]=o.shapeBackground((0,r.nd)((0,r.nc)(),u,t));s.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding);const l=2*Math.max(n.width,n.height);s.recordBounds(e.x+n.x,e.y+n.y,l,l),this._writeTextBox(s,i,e.x,e.y,a,c,m),s.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const t=(0,r.gC)(p,_),[n,a]=o.shapeBackground((0,r.nd)((0,r.nc)(),u,t));m.clipAngle=f,s.recordStart(this.instanceId,this.attributeLayout,o.glyphs[0].textureBinding);const l=2*Math.max(n.width,n.height);s.recordBounds(e.x+n.x,e.y+n.y,l,l),this._writeTextBox(s,i,e.x,e.y,a,c,m),s.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(u,t,1,d,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(u,t,0,f,!0),s.metricEnd()}_placeBack(e,t,s,i,r,n){const o=e.clone();let a=e.backwardLength+S;for(;o.prev()&&!(a>=i);)this._placeOnSegment(o,t,a,s,-1,r,n),a+=o.length+S}_placeForward(e,t,s,i,r,n){const o=e.clone();let a=e.remainingLength+S;for(;o.next()&&!(a>=i);)this._placeOnSegment(o,t,a,s,1,r,n),a+=o.length+S}_placeFirst(e,t,s,i,r=!1){const{out:o,id:a,shaping:c,zoomRange:l,referenceBounds:h}=this._current,u=c.glyphs;for(const d of u){const u=d.x>c.bounds.x?s:1-s,f=u*e.remainingLength+(1-u)*e.backwardLength,m=Math.abs(d.x+d.width/2-c.bounds.x),p=Math.max(0,this._zoomLevel+Math.log2(m/(f+S))),_=Math.max(t,r?0:p);d.maxZoom=Math.min(l[1],n.P),d.angle=e.angle+(1-s)*Math.PI,d.minZoom=Math.max(l[0],_),this._writeLineGlyph(o,a,e.x,e.y,c.bounds,d,i,h,!0),(s||this._current.offsetDirection)&&this._isVisible(d.minZoom,d.maxZoom)&&o.metricBoxWrite(d.bounds)}}_placeOnSegment(e,t,s,i,r,n,o){const{out:a,id:c,shaping:l,referenceBounds:h}=this._current,u=l.glyphs,d=e.dx/e.length,f=e.dy/e.length,m={x:e.x+s*-r*d,y:e.y+s*-r*f};for(const p of u){const t=p.x>l.bounds.x?n:1-n;if(!(t&&1===r||!t&&-1===r))continue;const u=Math.abs(p.x+p.width/2-l.bounds.x),d=Math.max(0,this._zoomLevel+Math.log2(u/s)-.1),f=Math.max(i,this._zoomLevel+Math.log2(u/(s+e.length+S)));0!==d&&(p.angle=e.angle+(1-n)*Math.PI,p.minZoom=f,p.maxZoom=d,this._writeLineGlyph(a,c,m.x,m.y,l.bounds,p,o,h,!0),(n||this._current.offsetDirection)&&this._isVisible(p.minZoom,p.maxZoom)&&a.metricBoxWrite(p.bounds))}}_writeLineGlyph(e,t,s,i,r,o,a,c,l){const h=s+r.x,u=i+r.y,d=2*(this.evaluatedMeshParams.minPixelBuffer?this.evaluatedMeshParams.minPixelBuffer/this._textMeshTransformProps.fontSize:1),f=Math.max(r.width,r.height)*d;e.recordStart(this.instanceId,this.attributeLayout,o.textureBinding),e.recordBounds(h,u,f,f);const{texcoords:m,offsets:p}=o,{fontSize:_,haloSize:g,outlineSize:y}=this._textMeshTransformProps;this._writeQuad(e,t,s,i,{texcoords:m,offsets:p,fontSize:_,haloSize:g,outlineSize:y,color:(0,n.g)(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:c,minZoom:Math.max(this._current.zoomRange[0],o.minZoom),maxZoom:Math.min(this._current.zoomRange[1],o.maxZoom),clipAngle:a,mapAligned:l,isLineLabel:!0}),e.recordEnd()}_isVisible(e,t){const s=Math.floor(this._zoomLevel*r.na)/r.na;return e<=s&&s<=t}}function z(e,t,s){const{coords:i,lengths:n}=t,o=(0,r.g_)(),a=(0,r.g_)(),c=(0,r.g_)(),l=(0,r.g_)(),h=(0,r.g_)(),u=(0,r.g_)(),d=2;let f=0;for(let m=0;m<n.length;m++){const t=n[m];for(let n=0;n<t;n++){const m=d*(n+f-1),p=d*(n+f),_=d*(n+f+1);n>0?(0,r.gV)(o,i[m],i[m+1]):(0,r.gV)(o,0,0),(0,r.gV)(a,i[p],i[p+1]),n<t-1?(0,r.gV)(c,i[_],i[_+1]):(0,r.gV)(c,0,0),0===n?(0,r.gV)(l,0,0):((0,r.ne)(l,a,o),(0,r.nf)(l,l),(0,r.gV)(l,l[1],-l[0])),n===t-1?(0,r.gV)(h,0,0):((0,r.ne)(h,c,a),(0,r.nf)(h,h),(0,r.gV)(h,h[1],-h[0])),(0,r.ng)(u,l,h),(0,r.nf)(u,u);const g=u[0]*h[0]+u[1]*h[1];0!==g&&(0,r.nh)(u,u,g),(0,r.nh)(u,u,s),e.coords.push(a[0]+u[0],a[1]+u[1])}e.lengths.push(t),f+=t}return e}function E(e){return e instanceof D?e:"object"==typeof e&&"type"in e?C[e.type].hydrate(e):new T(e)}class D{constructor(e){this.inputs=e}encode(){const e=[];for(const t of this.inputs)e.push(...t.encode());return e.push(...this.instructions),e}}let T=class extends D{constructor(e){super([]),this.value=e}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[e,t,s,r]=this.value;return null!=r?i.s.vector4.encode([e,t||0,s||0,r]):i.s.vector3.encode([e,t||0,s||0])}return i.s.scalar.encode(this.value)}},B=class e extends D{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(t){return new e(t,E(t.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const t=this._parent.simplify();if(!(t instanceof T))return this;const[s,i,r,n]=t.value,o=this._config.translation.from[0],a=this._config.translation.from[1],c=this._config.rotation.from,l=this._config.scale.from;if(o===this._config.translation.to[0]&&a===this._config.translation.to[1]&&c===this._config.rotation.to&&l===this._config.scale.to){const e=r+c,t=n*l,h=Math.sin(r),u=Math.cos(r);return new T([u*n*o-h*n*a+s,h*n*o+u*n*a+i,e,t])}return new e(this._config,t)}get instructions(){return i.s.animatedTransform.encode(this._config)}},R=class e extends D{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(t){return new e(t,E(t.parent))}simplify(){const t=this._parent.simplify();if(!(t instanceof T))return this;const[s,i,r,n]=t.value,o=this._config.color.from[0],a=this._config.color.from[1],c=this._config.color.from[2];let l=this._config.color.from[3];const h=this._config.opacity.from;return o===this._config.color.to[0]&&a===this._config.color.to[1]&&c===this._config.color.to[2]&&l===this._config.color.to[3]&&h===this._config.opacity.to?(l*=h,new T([s*o,i*a,r*c,n*l])):new e(this._config,t)}get instructions(){return i.s.animatedColor.encode(this._config)}};const C={AnimatedTransform:B,AnimatedColor:R};function F(e){return G(e.map((e=>W(e))).map((e=>E(e).simplify())))}function V(e){const t=[];return t.push(e.transform),t.push(e.fromColor),t.push(e.toColor),t.push(e.colorMix),t.push(e.toOpacity),t.push(e.opacityMix),t}function G(e){const t=[],s=[];let r=0;for(const n of e){const o=[...n.encode(),...i.s.ret.encode()];t.push([r+e.length,0,0,0]),s.push(...o),r+=o.length}return[...t,...s]}async function O(e,t){const s=e;let i;if("number"==typeof s||"string"==typeof s||"boolean"==typeof s)i=s;else if(Array.isArray(s))i=await Promise.all(s.map((e=>O(e,t))));else if("object"==typeof s)if("valueExpressionInfo"in s){const{valueExpressionInfo:e}=s,{expression:r}=e;i={...s,computed:await t.createComputedField({expression:r})}}else{i={};for(const e in s)i[e]=await O(s[e],t)}return i}function W(e,t,s){function i(e){if(!("computed"in e))return e;let i=e.computed.readWithDefault(t,s,[255*e.defaultValue[0],255*e.defaultValue[1],255*e.defaultValue[2],e.defaultValue[3]]);if("string"==typeof i){const e=r.h2.fromString(i);e&&(i=[e.r,e.g,e.b,e.a])}return i}const n=e;let o;if("number"==typeof n||"string"==typeof n||"boolean"==typeof n)o=n;else if(Array.isArray(n))o=n.map((e=>W(e,t,s)));else if("object"==typeof n)if("type"in n&&null!=n.type&&"Process"===n.type)switch(n.op){case"ArcadeColor":{const e=W(n.value,t,s);j(Array.isArray(e)&&4===e.length),o=[e[0]/255,e[1]/255,e[2]/255,e[3]]}break;case"Transparency":{const e=W(n.value,t,s);j("number"==typeof e),o=1-e/100}break;case"Divide":{const e=W(n.left,t,s);j("number"==typeof e);const i=W(n.right,t,s);j("number"==typeof i),o=e/i}break;case"Random":{const e=W(n.seed,t,s),i=W(n.min,t,s),r=W(n.max,t,s),a=t.getObjectId(),l=(0,c.o)(a||0);o=i+(0,c.e)(l,e)*(r-i)}}else if("computed"in n)o=i(n);else{o={};for(const e in n)o[e]=W(n[e],t,s)}return o}function j(e){if(!e)throw new Error("Assertion failed.")}class N extends l.c{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,s){return this._value}referencesScale(){return!1}referencesGeometry(){return!1}}const q=()=>r.G.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function Z(e,t,s=!1){const{defaultValue:i,valueExpressionInfo:r,value:n}=t;if(r){const{expression:n}=r,o=await e.createComputedField({expression:n},s);return o?{...t,computed:o,defaultValue:i}:null}return{...t,computed:new N(n),defaultValue:i}}async function Y(e,t){const{valueExpressionInfo:s}=t,{expression:i}=s,r=await e.createComputedField({expression:i});return r?{...t,computed:r}:null}function X(e){return"object"==typeof e&&null!=e&&(!(!("valueExpressionInfo"in e)||!e.valueExpressionInfo)||"type"in e&&"Process"===e.type&&"op"in e&&"Random"===e.op)}function H(e){if(Array.isArray(e))for(const t of e)if(H(t))return!0;if("object"==typeof e){if(X(e))return!0;for(const t in e)if(H(e[t]))return!0}return!1}class Q{static async create(e,t,s){const i={},n=new Map,o=new Map,a=new Map,c=new Map,l=new Map,h=new Map;for(const u in s){const d=s[u];if(null!=d&&"object"==typeof d)if(Array.isArray(d)){if("object"==typeof d[0])throw new Error(`InternalError: Cannot handle ${u}. Nested array params are not supported`);i[u]=d}else if("valueExpressionInfo"in d){if(d.value){i[u]=d.value;continue}const t=await Y(e,d);if(!t){i[u]=d.defaultValue;continue}n.set(u,t),i[u]=null}else switch(d.type){case"cim-effect-infos":if(d.effectInfos.some((e=>e.overrides.length))){o.set(u,{effects:await Promise.all(d.effectInfos.map((async t=>{const s=t.overrides.map((t=>Z(e,t)));return{effect:t.effect,compiledOverrides:(await Promise.all(s)).filter(r.ci)}})))});break}i[u]=d.effectInfos.map((e=>e.effect));break;case"cim-marker-placement-param":d.overrides.length&&a.set(u,{placementInfo:d,compiledOverrides:(await Promise.all(d.overrides.map((t=>Z(e,t))))).filter(r.ci)}),i[u]=d.placement;break;case"text-rasterization-param":{if(d.overrides.length){const t=d.overrides.map((t=>Z(e,t,d.useLegacyLabelEvaluationRules)));c.set(u,{compiledOverrides:(await Promise.all(t)).filter(r.ci),rasterizationParam:d,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:d.resource};i[u]=await t.fetchResourceImmediate(s)??null;break}case"sprite-rasterization-param":{if(d.overrides.length){const t=d.overrides.map((t=>Z(e,t)));c.set(u,{compiledOverrides:(await Promise.all(t)).filter(r.ci),rasterizationParam:d,objectIdToResourceId:new Map});continue}if("animated"===d.resource.type){c.set(u,{compiledOverrides:[],rasterizationParam:d,objectIdToResourceId:new Map});continue}const s={type:"cim-rasterization-info",resource:d.resource};i[u]=await t.fetchResourceImmediate(s)??null;break}case"cim-marker-transform-param":{const{params:t}=d;if(H(t)){const s={compiledMarkerInfos:[]};await Promise.all(t.map((async t=>{const i={props:{}};for(const s in t)if(X(t[s])){const r=await Y(e,t[s]);i.compiledExpressionMap||(i.compiledExpressionMap=new Map);const n=i.compiledExpressionMap;r&&n.set(s,r)}else i.props[s]=t[s];s.compiledMarkerInfos.push(i)}))),l.set(u,s)}else i[u]={type:"cim-marker-transform-info",infos:t};break}case"animation-params":{const{params:s}=d,r=V(s);if(H(r)){const t=await Promise.all(r.map((t=>O(t,e))));h.set(u,{params:t,propertyIdToResourceId:new Map,key:u})}else{const e=F(r),s=await t.fetchResourceImmediate({type:"animation-info",resource:e});null!=s&&"sprite"===s.type&&(i[u]={dataRow:s.rect.y,dataColumn:s.rect.x})}break}default:i[u]=d}else i[u]=d}return new Q(s,i,n,o,a,c,l,h)}constructor(e,t,s,i,r,n,o,a){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=s,this._dynamicEffectProperties=i,this._dynamicPlacementProperties=r,this._dynamicAsyncProperties=n,this._dynamicTransformProperties=o,this._dynamicAsyncAnimations=a,this.evaluator=e=>e}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,s){for(const n of this._dynamicAsyncProperties.values()){const a=(0,r.T)(n.rasterizationParam.resource);"animated"===n.rasterizationParam.resource.type&&n.rasterizationParam.resource.randomizeStartTime&&(a.primitiveName="__RESERVED__PRIMITIVE__NAME__",a.startGroup=(0,c.o)(t.getObjectId()||0));for(const{primitiveName:e,propertyName:c,computed:h,defaultValue:u,valueExpressionInfo:d}of n.compiledOverrides)try{const i="animated"===n.rasterizationParam.resource.type?a.primitiveName:e;(0,o.t)(a,i,c,h,t,s,u)}catch(i){q().errorOnce(new r.s("invalid-arcade-expression",`Encountered an error when evaluating the arcade expression '${d?.expression}' (primitive: '${e}', property: '${c}')`,i))}const l=e.enqueueRequest({type:"cim-rasterization-info",resource:a});n.objectIdToResourceId.set(t.getObjectId(),l)}for(const r of this._dynamicAsyncAnimations.values()){const i=r.params.map((e=>W(e,t,s))).map(E).map((e=>e.simplify())),n=G(i),o=e.enqueueRequest({type:"animation-info",resource:n});r.propertyIdToResourceId.set(t.getObjectId()+"."+r.key,o)}}evaluateMeshParams(e,t,s){for(const[i,r]of this._dynamicProperties.entries())this._resolvedMeshParams[i]=r.computed.readWithDefault(t,s,r.defaultValue);for(const[i,r]of this._dynamicPlacementProperties.entries())for(const{computed:e,defaultValue:n,propertyName:o}of r.compiledOverrides){const a=e.readWithDefault(t,s,n);r.placementInfo.placement[o]=a,this._resolvedMeshParams[i]=r.placementInfo.placement}for(const[i,r]of this._dynamicEffectProperties.entries())for(const e of r.effects){for(const{computed:i,defaultValue:r,propertyName:n}of e.compiledOverrides){const o=i.readWithDefault(t,s,r);e.effect[n]=o}this._resolvedMeshParams[i]=r.effects.map((e=>e.effect))}for(const[i,r]of this._dynamicTransformProperties.entries()){const e={type:"cim-marker-transform-info",infos:[]};for(const i of r.compiledMarkerInfos){const r={...i.props};if(i.compiledExpressionMap)for(const[e,n]of i.compiledExpressionMap){const i=n.computed.readWithDefault(t,s,n.defaultValue);r[e]="number"==typeof i||"boolean"==typeof i?i:n.defaultValue}e.infos.push(r)}this._resolvedMeshParams[i]=e}for(const[i,r]of this._dynamicAsyncProperties.entries()){const s=r.objectIdToResourceId.get(t.getObjectId());if(null==s)continue;const n=e.getResource(s);this._resolvedMeshParams[i]=n}for(const[i,r]of this._dynamicAsyncAnimations.entries()){const s=r.propertyIdToResourceId.get(t.getObjectId()+"."+i);if(null==s)continue;const n=e.getResource(s);this._resolvedMeshParams[i]={dataRow:n.rect.y,dataColumn:n.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}}class ${async createMeshWriter(e,t,s,i){const r=this._getMeshWriter(i.techniqueType),n=await Q.create(e,t,i.inputParams),o=new r(i.id,n,i.optionalAttributes,s);return await o.loadDependencies(),o}_getMeshWriter(e){switch(e){case i.e.Fill:return n.j;case i.e.DotDensity:return n.e;case i.e.ComplexFill:return n.d;case i.e.PatternFill:return n.o;case i.e.OutlineFill:return n.h;case i.e.PatternOutlineFill:return n.b;case i.e.ComplexOutlineFill:return n.a;case i.e.Marker:return n._;case i.e.PieChart:return n.s;case i.e.Text:return n.N;case i.e.Line:return n.T;case i.e.TexturedLine:return n.l;case i.e.Heatmap:return n.i;case i.e.Label:return L;case i.e.AnimatedMarker:return d;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}},13444:function(e,t,s){s.d(t,{e:function(){return r},o:function(){return n}});var i=s(44444);function r(e,t){let s;if("string"==typeof e)s=(0,i.b1)(e+`-seed(${t})`);else{let i=12;s=e^t;do{s=107*(s>>8^s)+i|0}while(0!=--i)}return(1+s/(1<<31))/2}function n(e){return Math.floor(r(e,o)*a)}const o=53290320,a=10}}]);
//# sourceMappingURL=9868.9b9626e8.js.map